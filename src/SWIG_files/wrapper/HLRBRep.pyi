from enum import IntEnum
from typing import overload, NewType, Optional, Tuple

from OCC.Core.Standard import *
from OCC.Core.NCollection import *
from OCC.Core.TopoDS import *
from OCC.Core.HLRAlgo import *
from OCC.Core.TopAbs import *
from OCC.Core.BRepAdaptor import *
from OCC.Core.Geom import *
from OCC.Core.gp import *
from OCC.Core.GeomAbs import *
from OCC.Core.TColStd import *
from OCC.Core.TColgp import *
from OCC.Core.IntRes2d import *
from OCC.Core.Geom2d import *
from OCC.Core.TopTools import *
from OCC.Core.BRepTopAdaptor import *
from OCC.Core.IntCurveSurface import *
from OCC.Core.Bnd import *
from OCC.Core.HLRTopoBRep import *
from OCC.Core.math import *
from OCC.Core.IntCurve import *
from OCC.Core.Extrema import *
from OCC.Core.Adaptor3d import *
from OCC.Core.Intf import *
from OCC.Core.IntSurf import *


class HLRBRep_TypeOfResultingEdge(IntEnum):
	HLRBRep_Undefined: int = ...
	HLRBRep_IsoLine: int = ...
	HLRBRep_OutLine: int = ...
	HLRBRep_Rg1Line: int = ...
	HLRBRep_RgNLine: int = ...
	HLRBRep_Sharp: int = ...
HLRBRep_Undefined = HLRBRep_TypeOfResultingEdge.HLRBRep_Undefined
HLRBRep_IsoLine = HLRBRep_TypeOfResultingEdge.HLRBRep_IsoLine
HLRBRep_OutLine = HLRBRep_TypeOfResultingEdge.HLRBRep_OutLine
HLRBRep_Rg1Line = HLRBRep_TypeOfResultingEdge.HLRBRep_Rg1Line
HLRBRep_RgNLine = HLRBRep_TypeOfResultingEdge.HLRBRep_RgNLine
HLRBRep_Sharp = HLRBRep_TypeOfResultingEdge.HLRBRep_Sharp

class HLRBRep:
	@staticmethod
	def MakeEdge(self, ec: HLRBRep_Curve, U1: float, U2: float) -> TopoDS_Edge: ...
	@staticmethod
	def MakeEdge3d(self, ec: HLRBRep_Curve, U1: float, U2: float) -> TopoDS_Edge: ...
	@staticmethod
	def PolyHLRAngleAndDeflection(self, InAngl: float) -> Tuple[float, float]: ...

class HLRBRep_AreaLimit(Standard_Transient):
	def __init__(self, V: HLRAlgo_Intersection, Boundary: bool, Interference: bool, StateBefore: TopAbs_State, StateAfter: TopAbs_State, EdgeBefore: TopAbs_State, EdgeAfter: TopAbs_State) -> None: ...
	def Clear(self) -> None: ...
	def EdgeAfter(self, St: TopAbs_State) -> None: ...
	def EdgeAfter(self) -> TopAbs_State: ...
	def EdgeBefore(self, St: TopAbs_State) -> None: ...
	def EdgeBefore(self) -> TopAbs_State: ...
	def IsBoundary(self) -> bool: ...
	def IsInterference(self) -> bool: ...
	def Next(self, N: HLRBRep_AreaLimit) -> None: ...
	def Next(self) -> HLRBRep_AreaLimit: ...
	def Previous(self, P: HLRBRep_AreaLimit) -> None: ...
	def Previous(self) -> HLRBRep_AreaLimit: ...
	def StateAfter(self, St: TopAbs_State) -> None: ...
	def StateAfter(self) -> TopAbs_State: ...
	def StateBefore(self, St: TopAbs_State) -> None: ...
	def StateBefore(self) -> TopAbs_State: ...
	def Vertex(self) -> HLRAlgo_Intersection: ...

class HLRBRep_BCurveTool:
	@staticmethod
	def BSpline(self, C: BRepAdaptor_Curve) -> Geom_BSplineCurve: ...
	@staticmethod
	def Bezier(self, C: BRepAdaptor_Curve) -> Geom_BezierCurve: ...
	@staticmethod
	def Circle(self, C: BRepAdaptor_Curve) -> gp_Circ: ...
	@staticmethod
	def Continuity(self, C: BRepAdaptor_Curve) -> GeomAbs_Shape: ...
	@staticmethod
	def D0(self, C: BRepAdaptor_Curve, U: float, P: gp_Pnt) -> None: ...
	@staticmethod
	def D1(self, C: BRepAdaptor_Curve, U: float, P: gp_Pnt, V: gp_Vec) -> None: ...
	@staticmethod
	def D2(self, C: BRepAdaptor_Curve, U: float, P: gp_Pnt, V1: gp_Vec, V2: gp_Vec) -> None: ...
	@staticmethod
	def D3(self, C: BRepAdaptor_Curve, U: float, P: gp_Pnt, V1: gp_Vec, V2: gp_Vec, V3: gp_Vec) -> None: ...
	@staticmethod
	def DN(self, C: BRepAdaptor_Curve, U: float, N: int) -> gp_Vec: ...
	@staticmethod
	def Degree(self, C: BRepAdaptor_Curve) -> int: ...
	@staticmethod
	def Ellipse(self, C: BRepAdaptor_Curve) -> gp_Elips: ...
	@staticmethod
	def FirstParameter(self, C: BRepAdaptor_Curve) -> float: ...
	@staticmethod
	def GetType(self, C: BRepAdaptor_Curve) -> GeomAbs_CurveType: ...
	@staticmethod
	def Hyperbola(self, C: BRepAdaptor_Curve) -> gp_Hypr: ...
	@staticmethod
	def Intervals(self, C: BRepAdaptor_Curve, T: TColStd_Array1OfReal, S: GeomAbs_Shape) -> None: ...
	@staticmethod
	def IsClosed(self, C: BRepAdaptor_Curve) -> bool: ...
	@staticmethod
	def IsPeriodic(self, C: BRepAdaptor_Curve) -> bool: ...
	@staticmethod
	def IsRational(self, C: BRepAdaptor_Curve) -> bool: ...
	@staticmethod
	def LastParameter(self, C: BRepAdaptor_Curve) -> float: ...
	@staticmethod
	def Line(self, C: BRepAdaptor_Curve) -> gp_Lin: ...
	@staticmethod
	def NbIntervals(self, C: BRepAdaptor_Curve, S: GeomAbs_Shape) -> int: ...
	@staticmethod
	def NbKnots(self, C: BRepAdaptor_Curve) -> int: ...
	@staticmethod
	def NbPoles(self, C: BRepAdaptor_Curve) -> int: ...
	@staticmethod
	def NbSamples(self, C: BRepAdaptor_Curve, U0: float, U1: float) -> int: ...
	@staticmethod
	def Parabola(self, C: BRepAdaptor_Curve) -> gp_Parab: ...
	@staticmethod
	def Period(self, C: BRepAdaptor_Curve) -> float: ...
	@staticmethod
	def Poles(self, C: BRepAdaptor_Curve, T: TColgp_Array1OfPnt) -> None: ...
	@staticmethod
	def PolesAndWeights(self, C: BRepAdaptor_Curve, T: TColgp_Array1OfPnt, W: TColStd_Array1OfReal) -> None: ...
	@staticmethod
	def Resolution(self, C: BRepAdaptor_Curve, R3d: float) -> float: ...
	@staticmethod
	def Value(self, C: BRepAdaptor_Curve, U: float) -> gp_Pnt: ...

class HLRBRep_BiPnt2D:
	@overload
	def __init__(self) -> None: ...
	@overload
	def __init__(self, x1: float, y1: float, x2: float, y2: float, S: TopoDS_Shape, reg1: bool, regn: bool, outl: bool, intl: bool) -> None: ...
	@overload
	def __init__(self, thePoint1: gp_XY, thePoint2: gp_XY, S: TopoDS_Shape, reg1: bool, regn: bool, outl: bool, intl: bool) -> None: ...
	def IntLine(self) -> bool: ...
	def IntLine(self, B: bool) -> None: ...
	def OutLine(self) -> bool: ...
	def OutLine(self, B: bool) -> None: ...
	def P1(self) -> gp_Pnt2d: ...
	def P2(self) -> gp_Pnt2d: ...
	def Rg1Line(self) -> bool: ...
	def Rg1Line(self, B: bool) -> None: ...
	def RgNLine(self) -> bool: ...
	def RgNLine(self, B: bool) -> None: ...
	def Shape(self) -> TopoDS_Shape: ...
	def Shape(self, S: TopoDS_Shape) -> None: ...

class HLRBRep_BiPoint:
	@overload
	def __init__(self) -> None: ...
	@overload
	def __init__(self, x1: float, y1: float, z1: float, x2: float, y2: float, z2: float, S: TopoDS_Shape, reg1: bool, regn: bool, outl: bool, intl: bool) -> None: ...
	def IntLine(self) -> bool: ...
	def IntLine(self, B: bool) -> None: ...
	def OutLine(self) -> bool: ...
	def OutLine(self, B: bool) -> None: ...
	def P1(self) -> gp_Pnt: ...
	def P2(self) -> gp_Pnt: ...
	def Rg1Line(self) -> bool: ...
	def Rg1Line(self, B: bool) -> None: ...
	def RgNLine(self) -> bool: ...
	def RgNLine(self, B: bool) -> None: ...
	def Shape(self) -> TopoDS_Shape: ...
	def Shape(self, S: TopoDS_Shape) -> None: ...

class HLRBRep_CInter(IntRes2d_Intersection):
	@overload
	def __init__(self) -> None: ...
	@overload
	def __init__(self, C: None, TolConf: float, Tol: float) -> None: ...
	@overload
	def __init__(self, C: None, D: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	@overload
	def __init__(self, C1: None, C2: None, TolConf: float, Tol: float) -> None: ...
	@overload
	def __init__(self, C1: None, D1: IntRes2d_Domain, C2: None, TolConf: float, Tol: float) -> None: ...
	@overload
	def __init__(self, C1: None, C2: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	@overload
	def __init__(self, C1: None, D1: IntRes2d_Domain, C2: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def ComputeDomain(self, C1: None, TolDomain: float) -> IntRes2d_Domain: ...
	def GetMinNbSamples(self) -> int: ...
	def Perform(self, C1: None, D1: IntRes2d_Domain, C2: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def Perform(self, C1: None, C2: None, TolConf: float, Tol: float) -> None: ...
	def Perform(self, C1: None, D1: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def Perform(self, C1: None, TolConf: float, Tol: float) -> None: ...
	def Perform(self, C1: None, D1: IntRes2d_Domain, C2: None, TolConf: float, Tol: float) -> None: ...
	def Perform(self, C1: None, C2: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def SetMinNbSamples(self, theMinNbSamples: int) -> None: ...

class HLRBRep_CLProps:
	@overload
	def __init__(self, C: HLRBRep_Curve, N: int, Resolution: float) -> None: ...
	@overload
	def __init__(self, C: HLRBRep_Curve, U: float, N: int, Resolution: float) -> None: ...
	@overload
	def __init__(self, N: int, Resolution: float) -> None: ...
	def CentreOfCurvature(self, P: gp_Pnt2d) -> None: ...
	def Curvature(self) -> float: ...
	def D1(self) -> gp_Vec2d: ...
	def D2(self) -> gp_Vec2d: ...
	def D3(self) -> gp_Vec2d: ...
	def IsTangentDefined(self) -> bool: ...
	def Normal(self, N: gp_Dir2d) -> None: ...
	def SetCurve(self, C: HLRBRep_Curve) -> None: ...
	def SetParameter(self, U: float) -> None: ...
	def Tangent(self, D: gp_Dir2d) -> None: ...
	def Value(self) -> gp_Pnt2d: ...

class HLRBRep_CLPropsATool:
	@staticmethod
	def Continuity(self, A: HLRBRep_Curve) -> int: ...
	@staticmethod
	def D1(self, A: HLRBRep_Curve, U: float, P: gp_Pnt2d, V1: gp_Vec2d) -> None: ...
	@staticmethod
	def D2(self, A: HLRBRep_Curve, U: float, P: gp_Pnt2d, V1: gp_Vec2d, V2: gp_Vec2d) -> None: ...
	@staticmethod
	def D3(self, A: HLRBRep_Curve, U: float, P: gp_Pnt2d, V1: gp_Vec2d, V2: gp_Vec2d, V3: gp_Vec2d) -> None: ...
	@staticmethod
	def FirstParameter(self, A: HLRBRep_Curve) -> float: ...
	@staticmethod
	def LastParameter(self, A: HLRBRep_Curve) -> float: ...
	@staticmethod
	def Value(self, A: HLRBRep_Curve, U: float, P: gp_Pnt2d) -> None: ...

class HLRBRep_Curve:
	def __init__(self) -> None: ...
	def Circle(self) -> gp_Circ2d: ...
	def Continuity(self) -> GeomAbs_Shape: ...
	def Curve(self) -> BRepAdaptor_Curve: ...
	def Curve(self, E: TopoDS_Edge) -> None: ...
	def D0(self, U: float, P: gp_Pnt) -> None: ...
	def D0(self, U: float, P: gp_Pnt2d) -> None: ...
	def D1(self, U: float, P: gp_Pnt, V: gp_Vec) -> None: ...
	def D1(self, U: float, P: gp_Pnt2d, V: gp_Vec2d) -> None: ...
	def D2(self, U: float, P: gp_Pnt2d, V1: gp_Vec2d, V2: gp_Vec2d) -> None: ...
	def D3(self, U: float, P: gp_Pnt2d, V1: gp_Vec2d, V2: gp_Vec2d, V3: gp_Vec2d) -> None: ...
	def DN(self, U: float, N: int) -> gp_Vec2d: ...
	def Degree(self) -> int: ...
	def Ellipse(self) -> gp_Elips2d: ...
	def FirstParameter(self) -> float: ...
	def GetCurve(self) -> BRepAdaptor_Curve: ...
	def GetType(self) -> GeomAbs_CurveType: ...
	def Hyperbola(self) -> gp_Hypr2d: ...
	def Intervals(self, T: TColStd_Array1OfReal, S: GeomAbs_Shape) -> None: ...
	def IsClosed(self) -> bool: ...
	def IsPeriodic(self) -> bool: ...
	def IsRational(self) -> bool: ...
	def Knots(self, kn: TColStd_Array1OfReal) -> None: ...
	def LastParameter(self) -> float: ...
	def Line(self) -> gp_Lin2d: ...
	def Multiplicities(self, mu: TColStd_Array1OfInteger) -> None: ...
	def NbIntervals(self, S: GeomAbs_Shape) -> int: ...
	def NbKnots(self) -> int: ...
	def NbPoles(self) -> int: ...
	def Parabola(self) -> gp_Parab2d: ...
	def Parameter2d(self, P3d: float) -> float: ...
	def Parameter3d(self, P2d: float) -> float: ...
	def Period(self) -> float: ...
	def Poles(self, TP: TColgp_Array1OfPnt2d) -> None: ...
	def Poles(self, aCurve: Geom_BSplineCurve, TP: TColgp_Array1OfPnt2d) -> None: ...
	def PolesAndWeights(self, TP: TColgp_Array1OfPnt2d, TW: TColStd_Array1OfReal) -> None: ...
	def PolesAndWeights(self, aCurve: Geom_BSplineCurve, TP: TColgp_Array1OfPnt2d, TW: TColStd_Array1OfReal) -> None: ...
	def Projector(self, Proj: HLRAlgo_Projector) -> None: ...
	def Resolution(self, R3d: float) -> float: ...
	def Tangent(self, AtStart: bool, P: gp_Pnt2d, D: gp_Dir2d) -> None: ...
	def Update(self, TotMin_list: List[float], TotMax_list: List[float]) -> float: ...
	def UpdateMinMax(self, TotMin_list: List[float], TotMax_list: List[float]) -> float: ...
	def Value(self, U: float) -> gp_Pnt2d: ...
	def Value3D(self, U: float) -> gp_Pnt: ...
	def Z(self, U: float) -> float: ...

class HLRBRep_CurveTool:
	@staticmethod
	def BSpline(self, C: None) -> Geom2d_BSplineCurve: ...
	@staticmethod
	def Bezier(self, C: None) -> Geom2d_BezierCurve: ...
	@staticmethod
	def Circle(self, C: None) -> gp_Circ2d: ...
	@staticmethod
	def Continuity(self, C: None) -> GeomAbs_Shape: ...
	@staticmethod
	def D0(self, C: None, U: float, P: gp_Pnt2d) -> None: ...
	@staticmethod
	def D1(self, C: None, U: float, P: gp_Pnt2d, V: gp_Vec2d) -> None: ...
	@staticmethod
	def D2(self, C: None, U: float, P: gp_Pnt2d, V1: gp_Vec2d, V2: gp_Vec2d) -> None: ...
	@staticmethod
	def D3(self, C: None, U: float, P: gp_Pnt2d, V1: gp_Vec2d, V2: gp_Vec2d, V3: gp_Vec2d) -> None: ...
	@staticmethod
	def DN(self, C: None, U: float, N: int) -> gp_Vec2d: ...
	@staticmethod
	def Degree(self, C: None) -> int: ...
	@staticmethod
	def Ellipse(self, C: None) -> gp_Elips2d: ...
	@staticmethod
	def EpsX(self, C: None) -> float: ...
	@staticmethod
	def FirstParameter(self, C: None) -> float: ...
	@staticmethod
	def GetInterval(self, C: None, Index: int, Tab: TColStd_Array1OfReal) -> Tuple[float, float]: ...
	@staticmethod
	def GetType(self, C: None) -> GeomAbs_CurveType: ...
	@staticmethod
	def Hyperbola(self, C: None) -> gp_Hypr2d: ...
	@staticmethod
	def Intervals(self, C: None, T: TColStd_Array1OfReal) -> None: ...
	@staticmethod
	def IsClosed(self, C: None) -> bool: ...
	@staticmethod
	def IsPeriodic(self, C: None) -> bool: ...
	@staticmethod
	def LastParameter(self, C: None) -> float: ...
	@staticmethod
	def Line(self, C: None) -> gp_Lin2d: ...
	@staticmethod
	def NbIntervals(self, C: None) -> int: ...
	@staticmethod
	def NbSamples(self, C: None, U0: float, U1: float) -> int: ...
	@staticmethod
	def NbSamples(self, C: None) -> int: ...
	@staticmethod
	def Parabola(self, C: None) -> gp_Parab2d: ...
	@staticmethod
	def Period(self, C: None) -> float: ...
	@staticmethod
	def Resolution(self, C: None, R3d: float) -> float: ...
	@staticmethod
	def TheType(self, C: None) -> GeomAbs_CurveType: ...
	@staticmethod
	def Value(self, C: None, U: float) -> gp_Pnt2d: ...

class HLRBRep_Data(Standard_Transient):
	def __init__(self, NV: int, NE: int, NF: int) -> None: ...
	def AboveInterference(self) -> bool: ...
	def Classify(self, E: int, ED: HLRBRep_EdgeData, LevelFlag: bool, param: float) -> Tuple[TopAbs_State, int]: ...
	def Compare(self, E: int, ED: HLRBRep_EdgeData) -> TopAbs_State: ...
	def Destroy(self) -> None: ...
	def EDataArray(self) -> HLRBRep_Array1OfEData: ...
	def Edge(self) -> int: ...
	def EdgeMap(self) -> TopTools_IndexedMapOfShape: ...
	def EdgeOfTheHidingFace(self, E: int, ED: HLRBRep_EdgeData) -> bool: ...
	def EdgeState(self, p1: float, p2: float, stbef: TopAbs_State, staf: TopAbs_State) -> None: ...
	def FDataArray(self) -> HLRBRep_Array1OfFData: ...
	def FaceMap(self) -> TopTools_IndexedMapOfShape: ...
	def HidingStartLevel(self, E: int, ED: HLRBRep_EdgeData, IL: HLRAlgo_InterferenceList) -> int: ...
	def HidingTheFace(self) -> bool: ...
	def InitEdge(self, FI: int, MST: BRepTopAdaptor_MapOfShapeTool) -> None: ...
	def InitInterference(self) -> None: ...
	def Interference(self) -> HLRAlgo_Interference: ...
	def IsBadFace(self) -> bool: ...
	def LocalFEGeometry2D(self, FE: int, Param: float, Tg: gp_Dir2d, Nm: gp_Dir2d) -> float: ...
	def LocalLEGeometry2D(self, Param: float, Tg: gp_Dir2d, Nm: gp_Dir2d) -> float: ...
	def MoreEdge(self) -> bool: ...
	def MoreInterference(self) -> bool: ...
	def NbEdges(self) -> int: ...
	def NbFaces(self) -> int: ...
	def NbVertices(self) -> int: ...
	def NextEdge(self, skip: Optional[bool]) -> None: ...
	def NextInterference(self) -> None: ...
	def Projector(self) -> HLRAlgo_Projector: ...
	def RejectedInterference(self) -> bool: ...
	def SimplClassify(self, E: int, ED: HLRBRep_EdgeData, Nbp: int, p1: float, p2: float) -> TopAbs_State: ...
	def SimpleHidingFace(self) -> bool: ...
	def Tolerance(self, tol: Standard_ShortReal) -> None: ...
	def Tolerance(self) -> Standard_ShortReal: ...
	def Update(self, P: HLRAlgo_Projector) -> None: ...
	def Write(self, DS: HLRBRep_Data, dv: int, de: int, df: int) -> None: ...

class HLRBRep_EdgeBuilder:
	def __init__(self, VList: HLRBRep_VertexList) -> None: ...
	def AreaEdgeState(self) -> TopAbs_State: ...
	def AreaState(self) -> TopAbs_State: ...
	def Builds(self, ToBuild: TopAbs_State) -> None: ...
	def Current(self) -> HLRAlgo_Intersection: ...
	def Destroy(self) -> None: ...
	def HasArea(self) -> bool: ...
	def InitAreas(self) -> None: ...
	def IsBoundary(self) -> bool: ...
	def IsInterference(self) -> bool: ...
	def LeftLimit(self) -> HLRBRep_AreaLimit: ...
	def MoreEdges(self) -> bool: ...
	def MoreVertices(self) -> bool: ...
	def NextArea(self) -> None: ...
	def NextEdge(self) -> None: ...
	def NextVertex(self) -> None: ...
	def Orientation(self) -> TopAbs_Orientation: ...
	def PreviousArea(self) -> None: ...
	def RightLimit(self) -> HLRBRep_AreaLimit: ...

class HLRBRep_EdgeData:
	def __init__(self) -> None: ...
	def AutoIntersectionDone(self) -> bool: ...
	def AutoIntersectionDone(self, B: bool) -> None: ...
	def ChangeGeometry(self) -> HLRBRep_Curve: ...
	def Curve(self) -> HLRBRep_Curve: ...
	def CutAtEnd(self) -> bool: ...
	def CutAtEnd(self, B: bool) -> None: ...
	def CutAtSta(self) -> bool: ...
	def CutAtSta(self, B: bool) -> None: ...
	def Geometry(self) -> HLRBRep_Curve: ...
	def HideCount(self) -> int: ...
	def HideCount(self, I: int) -> None: ...
	def MinMax(self) -> False: ...
	def OutLVEnd(self) -> bool: ...
	def OutLVEnd(self, B: bool) -> None: ...
	def OutLVSta(self) -> bool: ...
	def OutLVSta(self, B: bool) -> None: ...
	def Rg1Line(self) -> bool: ...
	def Rg1Line(self, B: bool) -> None: ...
	def RgNLine(self) -> bool: ...
	def RgNLine(self, B: bool) -> None: ...
	def Selected(self) -> bool: ...
	def Selected(self, B: bool) -> None: ...
	def Set(self, Reg1: bool, RegN: bool, EG: TopoDS_Edge, V1: int, V2: int, Out1: bool, Out2: bool, Cut1: bool, Cut2: bool, Start: float, TolStart: Standard_ShortReal, End: float, TolEnd: Standard_ShortReal) -> None: ...
	def Simple(self) -> bool: ...
	def Simple(self, B: bool) -> None: ...
	def Status(self) -> HLRAlgo_EdgeStatus: ...
	def Tolerance(self) -> Standard_ShortReal: ...
	def Used(self) -> bool: ...
	def Used(self, B: bool) -> None: ...
	def VEnd(self) -> int: ...
	def VEnd(self, I: int) -> None: ...
	def VSta(self) -> int: ...
	def VSta(self, I: int) -> None: ...
	def VerAtEnd(self) -> bool: ...
	def VerAtEnd(self, B: bool) -> None: ...
	def VerAtSta(self) -> bool: ...
	def VerAtSta(self, B: bool) -> None: ...
	def Vertical(self) -> bool: ...
	def Vertical(self, B: bool) -> None: ...

class HLRBRep_EdgeFaceTool:
	@staticmethod
	def CurvatureValue(self, F: None, U: float, V: float, Tg: gp_Dir) -> float: ...
	@staticmethod
	def UVPoint(self, Par: float, E: None, F: None) -> Tuple[bool, float, float]: ...

class HLRBRep_EdgeIList:
	@staticmethod
	def AddInterference(self, IL: HLRAlgo_InterferenceList, I: HLRAlgo_Interference, T: HLRBRep_EdgeInterferenceTool) -> None: ...
	@staticmethod
	def ProcessComplex(self, IL: HLRAlgo_InterferenceList, T: HLRBRep_EdgeInterferenceTool) -> None: ...

class HLRBRep_EdgeInterferenceTool:
	def __init__(self, DS: HLRBRep_Data) -> None: ...
	def CurrentOrientation(self) -> TopAbs_Orientation: ...
	def CurrentParameter(self) -> float: ...
	def CurrentVertex(self) -> HLRAlgo_Intersection: ...
	def EdgeGeometry(self, Param: float, Tgt: gp_Dir, Nrm: gp_Dir) -> float: ...
	def InitVertices(self) -> None: ...
	def InterferenceBoundaryGeometry(self, I: HLRAlgo_Interference, Tang: gp_Dir, Norm: gp_Dir) -> float: ...
	def IsPeriodic(self) -> bool: ...
	def LoadEdge(self) -> None: ...
	def MoreVertices(self) -> bool: ...
	def NextVertex(self) -> None: ...
	def ParameterOfInterference(self, I: HLRAlgo_Interference) -> float: ...
	def SameInterferences(self, I1: HLRAlgo_Interference, I2: HLRAlgo_Interference) -> bool: ...
	def SameVertexAndInterference(self, I: HLRAlgo_Interference) -> bool: ...

class HLRBRep_ExactIntersectionPointOfTheIntPCurvePCurveOfCInter:
	def __init__(self, C1: None, C2: None, Tol: float) -> None: ...
	def AnErrorOccurred(self) -> bool: ...
	def NbRoots(self) -> int: ...
	def Perform(self, Poly1: HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter, Poly2: HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter) -> Tuple[int, int, float, float]: ...
	def Perform(self, Uo: float, Vo: float, UInf: float, VInf: float, USup: float, VSup: float) -> None: ...
	def Roots(self) -> Tuple[float, float]: ...

class HLRBRep_FaceData:
	def __init__(self) -> None: ...
	def Back(self) -> bool: ...
	def Back(self, B: bool) -> None: ...
	def Closed(self) -> bool: ...
	def Closed(self, B: bool) -> None: ...
	def Cone(self) -> bool: ...
	def Cone(self, B: bool) -> None: ...
	def Cut(self) -> bool: ...
	def Cut(self, B: bool) -> None: ...
	def Cylinder(self) -> bool: ...
	def Cylinder(self, B: bool) -> None: ...
	def Geometry(self) -> HLRBRep_Surface: ...
	def Hiding(self) -> bool: ...
	def Hiding(self, B: bool) -> None: ...
	def Orientation(self) -> TopAbs_Orientation: ...
	def Orientation(self, O: TopAbs_Orientation) -> None: ...
	def Plane(self) -> bool: ...
	def Plane(self, B: bool) -> None: ...
	def Selected(self) -> bool: ...
	def Selected(self, B: bool) -> None: ...
	def Set(self, FG: TopoDS_Face, Or: TopAbs_Orientation, Cl: bool, NW: int) -> None: ...
	def SetWEdge(self, WI: int, EWI: int, EI: int, Or: TopAbs_Orientation, OutL: bool, Inte: bool, Dble: bool, IsoL: bool) -> None: ...
	def SetWire(self, WI: int, NE: int) -> None: ...
	def Side(self) -> bool: ...
	def Side(self, B: bool) -> None: ...
	def Simple(self) -> bool: ...
	def Simple(self, B: bool) -> None: ...
	def Size(self) -> float: ...
	def Size(self, S: float) -> None: ...
	def Sphere(self) -> bool: ...
	def Sphere(self, B: bool) -> None: ...
	def Tolerance(self) -> Standard_ShortReal: ...
	def Torus(self) -> bool: ...
	def Torus(self, B: bool) -> None: ...
	def Wires(self) -> HLRAlgo_WiresBlock: ...
	def WithOutL(self) -> bool: ...
	def WithOutL(self, B: bool) -> None: ...

class HLRBRep_FaceIterator:
	def __init__(self) -> None: ...
	def BeginningOfWire(self) -> bool: ...
	def Double(self) -> bool: ...
	def Edge(self) -> int: ...
	def EndOfWire(self) -> bool: ...
	def InitEdge(self, fd: HLRBRep_FaceData) -> None: ...
	def Internal(self) -> bool: ...
	def IsoLine(self) -> bool: ...
	def MoreEdge(self) -> bool: ...
	def NextEdge(self) -> None: ...
	def Orientation(self) -> TopAbs_Orientation: ...
	def OutLine(self) -> bool: ...
	def SkipWire(self) -> None: ...
	def Wire(self) -> HLRAlgo_EdgesBlock: ...

class HLRBRep_HLRToShape:
	def __init__(self, A: HLRBRep_Algo) -> None: ...
	def CompoundOfEdges(self, type: HLRBRep_TypeOfResultingEdge, visible: bool, In3d: bool) -> TopoDS_Shape: ...
	def CompoundOfEdges(self, S: TopoDS_Shape, type: HLRBRep_TypeOfResultingEdge, visible: bool, In3d: bool) -> TopoDS_Shape: ...
	def HCompound(self) -> TopoDS_Shape: ...
	def HCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def IsoLineHCompound(self) -> TopoDS_Shape: ...
	def IsoLineHCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def IsoLineVCompound(self) -> TopoDS_Shape: ...
	def IsoLineVCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def OutLineHCompound(self) -> TopoDS_Shape: ...
	def OutLineHCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def OutLineVCompound(self) -> TopoDS_Shape: ...
	def OutLineVCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def OutLineVCompound3d(self) -> TopoDS_Shape: ...
	def Rg1LineHCompound(self) -> TopoDS_Shape: ...
	def Rg1LineHCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def Rg1LineVCompound(self) -> TopoDS_Shape: ...
	def Rg1LineVCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def RgNLineHCompound(self) -> TopoDS_Shape: ...
	def RgNLineHCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def RgNLineVCompound(self) -> TopoDS_Shape: ...
	def RgNLineVCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def VCompound(self) -> TopoDS_Shape: ...
	def VCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...

class HLRBRep_Hider:
	def __init__(self, DS: HLRBRep_Data) -> None: ...
	def Hide(self, FI: int, MST: BRepTopAdaptor_MapOfShapeTool) -> None: ...
	def OwnHiding(self, FI: int) -> None: ...

class HLRBRep_IntConicCurveOfCInter(IntRes2d_Intersection):
	@overload
	def __init__(self) -> None: ...
	@overload
	def __init__(self, L: gp_Lin2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	@overload
	def __init__(self, C: gp_Circ2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	@overload
	def __init__(self, E: gp_Elips2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	@overload
	def __init__(self, Prb: gp_Parab2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	@overload
	def __init__(self, H: gp_Hypr2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def Perform(self, L: gp_Lin2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def Perform(self, C: gp_Circ2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def Perform(self, E: gp_Elips2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def Perform(self, Prb: gp_Parab2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def Perform(self, H: gp_Hypr2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...

class HLRBRep_InterCSurf(IntCurveSurface_Intersection):
	def __init__(self) -> None: ...
	def Perform(self, Curve: gp_Lin, Surface: None) -> None: ...
	def Perform(self, Curve: gp_Lin, Polygon: HLRBRep_ThePolygonOfInterCSurf, Surface: None) -> None: ...
	def Perform(self, Curve: gp_Lin, ThePolygon: HLRBRep_ThePolygonOfInterCSurf, Surface: None, Polyhedron: HLRBRep_ThePolyhedronOfInterCSurf) -> None: ...
	def Perform(self, Curve: gp_Lin, ThePolygon: HLRBRep_ThePolygonOfInterCSurf, Surface: None, Polyhedron: HLRBRep_ThePolyhedronOfInterCSurf, BndBSB: Bnd_BoundSortBox) -> None: ...
	def Perform(self, Curve: gp_Lin, Surface: None, Polyhedron: HLRBRep_ThePolyhedronOfInterCSurf) -> None: ...

class HLRBRep_InternalAlgo(Standard_Transient):
	@overload
	def __init__(self) -> None: ...
	@overload
	def __init__(self, A: HLRBRep_InternalAlgo) -> None: ...
	def DataStructure(self) -> HLRBRep_Data: ...
	def Debug(self, deb: bool) -> None: ...
	def Debug(self) -> bool: ...
	def Hide(self) -> None: ...
	def Hide(self, I: int) -> None: ...
	def Hide(self, I: int, J: int) -> None: ...
	def HideAll(self) -> None: ...
	def HideAll(self, I: int) -> None: ...
	def Index(self, S: HLRTopoBRep_OutLiner) -> int: ...
	def InitEdgeStatus(self) -> None: ...
	def Load(self, S: HLRTopoBRep_OutLiner, SData: Standard_Transient, nbIso: Optional[int]) -> None: ...
	def Load(self, S: HLRTopoBRep_OutLiner, nbIso: Optional[int]) -> None: ...
	def NbShapes(self) -> int: ...
	def PartialHide(self) -> None: ...
	def Projector(self, P: HLRAlgo_Projector) -> None: ...
	def Projector(self) -> HLRAlgo_Projector: ...
	def Remove(self, I: int) -> None: ...
	def Select(self) -> None: ...
	def Select(self, I: int) -> None: ...
	def SelectEdge(self, I: int) -> None: ...
	def SelectFace(self, I: int) -> None: ...
	def SeqOfShapeBounds(self) -> HLRBRep_SeqOfShapeBounds: ...
	def ShapeBounds(self, I: int) -> HLRBRep_ShapeBounds: ...
	def ShapeData(self, I: int, SData: Standard_Transient) -> None: ...
	def ShowAll(self) -> None: ...
	def ShowAll(self, I: int) -> None: ...
	def Update(self) -> None: ...

class HLRBRep_Intersector:
	def __init__(self) -> None: ...
	def CSPoint(self, N: int) -> IntCurveSurface_IntersectionPoint: ...
	def CSSegment(self, N: int) -> IntCurveSurface_IntersectionSegment: ...
	def Destroy(self) -> None: ...
	def IsDone(self) -> bool: ...
	def Load(self, A: None) -> None: ...
	def NbPoints(self) -> int: ...
	def NbSegments(self) -> int: ...
	def Perform(self, A1: None, da1: float, db1: float) -> None: ...
	def Perform(self, nA: int, A1: None, da1: float, db1: float, nB: int, A2: None, da2: float, db2: float, NoBound: bool) -> None: ...
	def Perform(self, L: gp_Lin, P: float) -> None: ...
	def Point(self, N: int) -> IntRes2d_IntersectionPoint: ...
	def Segment(self, N: int) -> IntRes2d_IntersectionSegment: ...
	def SimulateOnePoint(self, A1: None, U: float, A2: None, V: float) -> None: ...

class HLRBRep_LineTool:
	@staticmethod
	def BSpline(self, C: gp_Lin) -> Geom_BSplineCurve: ...
	@staticmethod
	def Bezier(self, C: gp_Lin) -> Geom_BezierCurve: ...
	@staticmethod
	def Circle(self, C: gp_Lin) -> gp_Circ: ...
	@staticmethod
	def Continuity(self, C: gp_Lin) -> GeomAbs_Shape: ...
	@staticmethod
	def D0(self, C: gp_Lin, U: float, P: gp_Pnt) -> None: ...
	@staticmethod
	def D1(self, C: gp_Lin, U: float, P: gp_Pnt, V: gp_Vec) -> None: ...
	@staticmethod
	def D2(self, C: gp_Lin, U: float, P: gp_Pnt, V1: gp_Vec, V2: gp_Vec) -> None: ...
	@staticmethod
	def D3(self, C: gp_Lin, U: float, P: gp_Pnt, V1: gp_Vec, V2: gp_Vec, V3: gp_Vec) -> None: ...
	@staticmethod
	def DN(self, C: gp_Lin, U: float, N: int) -> gp_Vec: ...
	@staticmethod
	def Degree(self, C: gp_Lin) -> int: ...
	@staticmethod
	def Ellipse(self, C: gp_Lin) -> gp_Elips: ...
	@staticmethod
	def FirstParameter(self, C: gp_Lin) -> float: ...
	@staticmethod
	def GetType(self, C: gp_Lin) -> GeomAbs_CurveType: ...
	@staticmethod
	def Hyperbola(self, C: gp_Lin) -> gp_Hypr: ...
	@staticmethod
	def IntervalContinuity(self, C: gp_Lin) -> GeomAbs_Shape: ...
	@staticmethod
	def IntervalFirst(self, C: gp_Lin) -> float: ...
	@staticmethod
	def IntervalLast(self, C: gp_Lin) -> float: ...
	@staticmethod
	def Intervals(self, C: gp_Lin, T: TColStd_Array1OfReal, Sh: GeomAbs_Shape) -> None: ...
	@staticmethod
	def IsClosed(self, C: gp_Lin) -> bool: ...
	@staticmethod
	def IsPeriodic(self, C: gp_Lin) -> bool: ...
	@staticmethod
	def IsRational(self, C: gp_Lin) -> bool: ...
	@staticmethod
	def KnotsAndMultiplicities(self, C: gp_Lin, TK: TColStd_Array1OfReal, TM: TColStd_Array1OfInteger) -> None: ...
	@staticmethod
	def LastParameter(self, C: gp_Lin) -> float: ...
	@staticmethod
	def Line(self, C: gp_Lin) -> gp_Lin: ...
	@staticmethod
	def NbIntervals(self, C: gp_Lin, S: GeomAbs_Shape) -> int: ...
	@staticmethod
	def NbKnots(self, C: gp_Lin) -> int: ...
	@staticmethod
	def NbPoles(self, C: gp_Lin) -> int: ...
	@staticmethod
	def NbSamples(self, C: gp_Lin, U0: float, U1: float) -> int: ...
	@staticmethod
	def Parabola(self, C: gp_Lin) -> gp_Parab: ...
	@staticmethod
	def Period(self, C: gp_Lin) -> float: ...
	@staticmethod
	def Poles(self, C: gp_Lin, TP: TColgp_Array1OfPnt) -> None: ...
	@staticmethod
	def PolesAndWeights(self, C: gp_Lin, TP: TColgp_Array1OfPnt, TW: TColStd_Array1OfReal) -> None: ...
	@staticmethod
	def Resolution(self, C: gp_Lin, R3d: float) -> float: ...
	@staticmethod
	def SamplePars(self, C: gp_Lin, U0: float, U1: float, Defl: float, NbMin: int, Pars: TColStd_HArray1OfReal) -> None: ...
	@staticmethod
	def Value(self, C: gp_Lin, U: float) -> gp_Pnt: ...

class HLRBRep_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfCInter(math_FunctionWithDerivative):
	def __init__(self, IT: IntCurve_IConicTool, PC: None) -> None: ...
	def Derivative(self, Param: float) -> Tuple[bool, float]: ...
	def Value(self, Param: float) -> Tuple[bool, float]: ...
	def Values(self, Param: float) -> Tuple[bool, float, float]: ...

class HLRBRep_PCLocFOfTheLocateExtPCOfTheProjPCurOfCInter(math_FunctionWithDerivative):
	@overload
	def __init__(self) -> None: ...
	@overload
	def __init__(self, P: gp_Pnt2d, C: None) -> None: ...
	def Derivative(self, U: float) -> Tuple[bool, float]: ...
	def GetStateNumber(self) -> int: ...
	def Initialize(self, C: None) -> None: ...
	def IsMin(self, N: int) -> bool: ...
	def NbExt(self) -> int: ...
	def Point(self, N: int) -> Extrema_POnCurv2d: ...
	def SearchOfTolerance(self) -> float: ...
	def SetPoint(self, P: gp_Pnt2d) -> None: ...
	def SquareDistance(self, N: int) -> float: ...
	def SubIntervalInitialize(self, theUfirst: float, theUlast: float) -> None: ...
	def Value(self, U: float) -> Tuple[bool, float]: ...
	def Values(self, U: float) -> Tuple[bool, float, float]: ...

class HLRBRep_PolyAlgo(Standard_Transient):
	@overload
	def __init__(self) -> None: ...
	@overload
	def __init__(self, A: HLRBRep_PolyAlgo) -> None: ...
	@overload
	def __init__(self, S: TopoDS_Shape) -> None: ...
	def Algo(self) -> HLRAlgo_PolyAlgo: ...
	def Angle(self) -> float: ...
	def Angle(self, Ang: float) -> None: ...
	def Debug(self) -> bool: ...
	def Debug(self, B: bool) -> None: ...
	def Hide(self, status: HLRAlgo_EdgeStatus, S: TopoDS_Shape) -> Tuple[False, bool, bool, bool, bool]: ...
	def Index(self, S: TopoDS_Shape) -> int: ...
	def InitHide(self) -> None: ...
	def InitShow(self) -> None: ...
	def Load(self, S: TopoDS_Shape) -> None: ...
	def MoreHide(self) -> bool: ...
	def MoreShow(self) -> bool: ...
	def NbShapes(self) -> int: ...
	def NextHide(self) -> None: ...
	def NextShow(self) -> None: ...
	def OutLinedShape(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def Projector(self) -> HLRAlgo_Projector: ...
	def Projector(self, P: HLRAlgo_Projector) -> None: ...
	def Remove(self, I: int) -> None: ...
	def Shape(self, I: int) -> TopoDS_Shape: ...
	def Show(self, S: TopoDS_Shape) -> Tuple[False, bool, bool, bool, bool]: ...
	def TolAngular(self) -> float: ...
	def TolAngular(self, Tol: float) -> None: ...
	def TolCoef(self) -> float: ...
	def TolCoef(self, Tol: float) -> None: ...
	def Update(self) -> None: ...

class HLRBRep_PolyHLRToShape:
	def __init__(self) -> None: ...
	def HCompound(self) -> TopoDS_Shape: ...
	def HCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def Hide(self) -> None: ...
	def OutLineHCompound(self) -> TopoDS_Shape: ...
	def OutLineHCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def OutLineVCompound(self) -> TopoDS_Shape: ...
	def OutLineVCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def Rg1LineHCompound(self) -> TopoDS_Shape: ...
	def Rg1LineHCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def Rg1LineVCompound(self) -> TopoDS_Shape: ...
	def Rg1LineVCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def RgNLineHCompound(self) -> TopoDS_Shape: ...
	def RgNLineHCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def RgNLineVCompound(self) -> TopoDS_Shape: ...
	def RgNLineVCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...
	def Show(self) -> None: ...
	def Update(self, A: HLRBRep_PolyAlgo) -> None: ...
	def VCompound(self) -> TopoDS_Shape: ...
	def VCompound(self, S: TopoDS_Shape) -> TopoDS_Shape: ...

class HLRBRep_SLProps:
	@overload
	def __init__(self, S: None, U: float, V: float, N: int, Resolution: float) -> None: ...
	@overload
	def __init__(self, S: None, N: int, Resolution: float) -> None: ...
	@overload
	def __init__(self, N: int, Resolution: float) -> None: ...
	def CurvatureDirections(self, MaxD: gp_Dir, MinD: gp_Dir) -> None: ...
	def D1U(self) -> gp_Vec: ...
	def D1V(self) -> gp_Vec: ...
	def D2U(self) -> gp_Vec: ...
	def D2V(self) -> gp_Vec: ...
	def DUV(self) -> gp_Vec: ...
	def GaussianCurvature(self) -> float: ...
	def IsCurvatureDefined(self) -> bool: ...
	def IsNormalDefined(self) -> bool: ...
	def IsTangentUDefined(self) -> bool: ...
	def IsTangentVDefined(self) -> bool: ...
	def IsUmbilic(self) -> bool: ...
	def MaxCurvature(self) -> float: ...
	def MeanCurvature(self) -> float: ...
	def MinCurvature(self) -> float: ...
	def Normal(self) -> gp_Dir: ...
	def SetParameters(self, U: float, V: float) -> None: ...
	def SetSurface(self, S: None) -> None: ...
	def TangentU(self, D: gp_Dir) -> None: ...
	def TangentV(self, D: gp_Dir) -> None: ...
	def Value(self) -> gp_Pnt: ...

class HLRBRep_SLPropsATool:
	@staticmethod
	def Bounds(self, A: None) -> Tuple[float, float, float, float]: ...
	@staticmethod
	def Continuity(self, A: None) -> int: ...
	@staticmethod
	def D1(self, A: None, U: float, V: float, P: gp_Pnt, D1U: gp_Vec, D1V: gp_Vec) -> None: ...
	@staticmethod
	def D2(self, A: None, U: float, V: float, P: gp_Pnt, D1U: gp_Vec, D1V: gp_Vec, D2U: gp_Vec, D2V: gp_Vec, DUV: gp_Vec) -> None: ...
	@staticmethod
	def DN(self, A: None, U: float, V: float, Nu: int, Nv: int) -> gp_Vec: ...
	@staticmethod
	def Value(self, A: None, U: float, V: float, P: gp_Pnt) -> None: ...

class HLRBRep_ShapeBounds:
	@overload
	def __init__(self) -> None: ...
	@overload
	def __init__(self, S: HLRTopoBRep_OutLiner, SData: Standard_Transient, nbIso: int, V1: int, V2: int, E1: int, E2: int, F1: int, F2: int) -> None: ...
	@overload
	def __init__(self, S: HLRTopoBRep_OutLiner, nbIso: int, V1: int, V2: int, E1: int, E2: int, F1: int, F2: int) -> None: ...
	def Bounds(self) -> Tuple[int, int, int, int, int, int]: ...
	def MinMax(self) -> False: ...
	def NbOfIso(self, nbIso: int) -> None: ...
	def NbOfIso(self) -> int: ...
	def Shape(self, S: HLRTopoBRep_OutLiner) -> None: ...
	def Shape(self) -> HLRTopoBRep_OutLiner: ...
	def ShapeData(self, SD: Standard_Transient) -> None: ...
	def ShapeData(self) -> Standard_Transient: ...
	def Sizes(self) -> Tuple[int, int, int]: ...
	def Translate(self, NV: int, NE: int, NF: int) -> None: ...

class HLRBRep_ShapeToHLR:
	@staticmethod
	def Load(self, S: HLRTopoBRep_OutLiner, P: HLRAlgo_Projector, MST: BRepTopAdaptor_MapOfShapeTool, nbIso: Optional[int]) -> HLRBRep_Data: ...

class HLRBRep_SurfaceTool:
	@staticmethod
	def AxeOfRevolution(self, S: None) -> gp_Ax1: ...
	@staticmethod
	def BSpline(self, S: None) -> Geom_BSplineSurface: ...
	@staticmethod
	def BasisCurve(self, S: None) -> Adaptor3d_HCurve: ...
	@staticmethod
	def BasisSurface(self, S: None) -> Adaptor3d_HSurface: ...
	@staticmethod
	def Bezier(self, S: None) -> Geom_BezierSurface: ...
	@staticmethod
	def Cone(self, S: None) -> gp_Cone: ...
	@staticmethod
	def Cylinder(self, S: None) -> gp_Cylinder: ...
	@staticmethod
	def D0(self, S: None, u: float, v: float, P: gp_Pnt) -> None: ...
	@staticmethod
	def D1(self, S: None, u: float, v: float, P: gp_Pnt, D1u: gp_Vec, D1v: gp_Vec) -> None: ...
	@staticmethod
	def D2(self, S: None, u: float, v: float, P: gp_Pnt, D1U: gp_Vec, D1V: gp_Vec, D2U: gp_Vec, D2V: gp_Vec, D2UV: gp_Vec) -> None: ...
	@staticmethod
	def D3(self, S: None, u: float, v: float, P: gp_Pnt, D1U: gp_Vec, D1V: gp_Vec, D2U: gp_Vec, D2V: gp_Vec, D2UV: gp_Vec, D3U: gp_Vec, D3V: gp_Vec, D3UUV: gp_Vec, D3UVV: gp_Vec) -> None: ...
	@staticmethod
	def DN(self, S: None, u: float, v: float, Nu: int, Nv: int) -> gp_Vec: ...
	@staticmethod
	def Direction(self, S: None) -> gp_Dir: ...
	@staticmethod
	def FirstUParameter(self, S: None) -> float: ...
	@staticmethod
	def FirstVParameter(self, S: None) -> float: ...
	@staticmethod
	def GetType(self, S: None) -> GeomAbs_SurfaceType: ...
	@staticmethod
	def IsUClosed(self, S: None) -> bool: ...
	@staticmethod
	def IsUPeriodic(self, S: None) -> bool: ...
	@staticmethod
	def IsVClosed(self, S: None) -> bool: ...
	@staticmethod
	def IsVPeriodic(self, S: None) -> bool: ...
	@staticmethod
	def LastUParameter(self, S: None) -> float: ...
	@staticmethod
	def LastVParameter(self, S: None) -> float: ...
	@staticmethod
	def NbSamplesU(self, S: None) -> int: ...
	@staticmethod
	def NbSamplesU(self, S: None, u1: float, u2: float) -> int: ...
	@staticmethod
	def NbSamplesV(self, S: None) -> int: ...
	@staticmethod
	def NbSamplesV(self, S: None, v1: float, v2: float) -> int: ...
	@staticmethod
	def NbUIntervals(self, S: None, Sh: GeomAbs_Shape) -> int: ...
	@staticmethod
	def NbVIntervals(self, S: None, Sh: GeomAbs_Shape) -> int: ...
	@staticmethod
	def OffsetValue(self, S: None) -> float: ...
	@staticmethod
	def Plane(self, S: None) -> gp_Pln: ...
	@staticmethod
	def Sphere(self, S: None) -> gp_Sphere: ...
	@staticmethod
	def Torus(self, S: None) -> gp_Torus: ...
	@staticmethod
	def UIntervals(self, S: None, T: TColStd_Array1OfReal, Sh: GeomAbs_Shape) -> None: ...
	@staticmethod
	def UPeriod(self, S: None) -> float: ...
	@staticmethod
	def UResolution(self, S: None, R3d: float) -> float: ...
	@staticmethod
	def UTrim(self, S: None, First: float, Last: float, Tol: float) -> Adaptor3d_HSurface: ...
	@staticmethod
	def VIntervals(self, S: None, T: TColStd_Array1OfReal, Sh: GeomAbs_Shape) -> None: ...
	@staticmethod
	def VPeriod(self, S: None) -> float: ...
	@staticmethod
	def VResolution(self, S: None, R3d: float) -> float: ...
	@staticmethod
	def VTrim(self, S: None, First: float, Last: float, Tol: float) -> Adaptor3d_HSurface: ...
	@staticmethod
	def Value(self, S: None, u: float, v: float) -> gp_Pnt: ...

class HLRBRep_TheCSFunctionOfInterCSurf(math_FunctionSetWithDerivatives):
	def __init__(self, S: None, C: gp_Lin) -> None: ...
	def AuxillarCurve(self) -> gp_Lin: ...
	def AuxillarSurface(self) -> None: ...
	def Derivatives(self, X: math_Vector, D: math_Matrix) -> bool: ...
	def NbEquations(self) -> int: ...
	def NbVariables(self) -> int: ...
	def Point(self) -> gp_Pnt: ...
	def Root(self) -> float: ...
	def Value(self, X: math_Vector, F: math_Vector) -> bool: ...
	def Values(self, X: math_Vector, F: math_Vector, D: math_Matrix) -> bool: ...

class HLRBRep_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfCInter(math_FunctionSetWithDerivatives):
	def __init__(self, curve1: None, curve2: None) -> None: ...
	def Derivatives(self, X: math_Vector, D: math_Matrix) -> bool: ...
	def NbEquations(self) -> int: ...
	def NbVariables(self) -> int: ...
	def Value(self, X: math_Vector, F: math_Vector) -> bool: ...
	def Values(self, X: math_Vector, F: math_Vector, D: math_Matrix) -> bool: ...

class HLRBRep_TheExactInterCSurf:
	@overload
	def __init__(self, U: float, V: float, W: float, F: HLRBRep_TheCSFunctionOfInterCSurf, TolTangency: float, MarginCoef: Optional[float]) -> None: ...
	@overload
	def __init__(self, F: HLRBRep_TheCSFunctionOfInterCSurf, TolTangency: float) -> None: ...
	def Function(self) -> HLRBRep_TheCSFunctionOfInterCSurf: ...
	def IsDone(self) -> bool: ...
	def IsEmpty(self) -> bool: ...
	def ParameterOnCurve(self) -> float: ...
	def ParameterOnSurface(self) -> Tuple[float, float]: ...
	def Perform(self, U: float, V: float, W: float, Rsnld: math_FunctionSetRoot, u0: float, v0: float, u1: float, v1: float, w0: float, w1: float) -> None: ...
	def Point(self) -> gp_Pnt: ...

class HLRBRep_TheIntConicCurveOfCInter(IntRes2d_Intersection):
	@overload
	def __init__(self) -> None: ...
	@overload
	def __init__(self, L: gp_Lin2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	@overload
	def __init__(self, C: gp_Circ2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	@overload
	def __init__(self, E: gp_Elips2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	@overload
	def __init__(self, Prb: gp_Parab2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	@overload
	def __init__(self, H: gp_Hypr2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def Perform(self, L: gp_Lin2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def Perform(self, C: gp_Circ2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def Perform(self, E: gp_Elips2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def Perform(self, Prb: gp_Parab2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def Perform(self, H: gp_Hypr2d, D1: IntRes2d_Domain, PCurve: None, D2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...

class HLRBRep_TheIntPCurvePCurveOfCInter(IntRes2d_Intersection):
	def __init__(self) -> None: ...
	def GetMinNbSamples(self) -> int: ...
	def Perform(self, Curve1: None, Domain1: IntRes2d_Domain, Curve2: None, Domain2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def Perform(self, Curve1: None, Domain1: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def SetMinNbSamples(self, theMinNbSamples: int) -> None: ...

class HLRBRep_TheInterferenceOfInterCSurf(Intf_Interference):
	@overload
	def __init__(self) -> None: ...
	@overload
	def __init__(self, thePolyg: HLRBRep_ThePolygonOfInterCSurf, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf) -> None: ...
	@overload
	def __init__(self, theLin: gp_Lin, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf) -> None: ...
	@overload
	def __init__(self, theLins: Intf_Array1OfLin, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf) -> None: ...
	@overload
	def __init__(self, thePolyg: HLRBRep_ThePolygonOfInterCSurf, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf, theBoundSB: Bnd_BoundSortBox) -> None: ...
	@overload
	def __init__(self, theLin: gp_Lin, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf, theBoundSB: Bnd_BoundSortBox) -> None: ...
	@overload
	def __init__(self, theLins: Intf_Array1OfLin, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf, theBoundSB: Bnd_BoundSortBox) -> None: ...
	def Interference(self, thePolyg: HLRBRep_ThePolygonOfInterCSurf, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf, theBoundSB: Bnd_BoundSortBox) -> None: ...
	def Interference(self, thePolyg: HLRBRep_ThePolygonOfInterCSurf, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf) -> None: ...
	def Perform(self, thePolyg: HLRBRep_ThePolygonOfInterCSurf, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf) -> None: ...
	def Perform(self, theLin: gp_Lin, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf) -> None: ...
	def Perform(self, theLins: Intf_Array1OfLin, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf) -> None: ...
	def Perform(self, thePolyg: HLRBRep_ThePolygonOfInterCSurf, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf, theBoundSB: Bnd_BoundSortBox) -> None: ...
	def Perform(self, theLin: gp_Lin, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf, theBoundSB: Bnd_BoundSortBox) -> None: ...
	def Perform(self, theLins: Intf_Array1OfLin, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf, theBoundSB: Bnd_BoundSortBox) -> None: ...

class HLRBRep_TheIntersectorOfTheIntConicCurveOfCInter(IntRes2d_Intersection):
	@overload
	def __init__(self) -> None: ...
	@overload
	def __init__(self, ITool: IntCurve_IConicTool, Dom1: IntRes2d_Domain, PCurve: None, Dom2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...
	def And_Domaine_Objet1_Intersections(self, TheImpTool: IntCurve_IConicTool, TheParCurve: None, TheImpCurveDomain: IntRes2d_Domain, TheParCurveDomain: IntRes2d_Domain, Inter2_And_Domain2: TColStd_Array1OfReal, Inter1: TColStd_Array1OfReal, Resultat1: TColStd_Array1OfReal, Resultat2: TColStd_Array1OfReal, EpsNul: float) -> int: ...
	def FindU(self, parameter: float, point: gp_Pnt2d, TheParCurev: None, TheImpTool: IntCurve_IConicTool) -> float: ...
	def FindV(self, parameter: float, point: gp_Pnt2d, TheImpTool: IntCurve_IConicTool, ParCurve: None, TheParCurveDomain: IntRes2d_Domain, V0: float, V1: float, Tolerance: float) -> float: ...
	def Perform(self, ITool: IntCurve_IConicTool, Dom1: IntRes2d_Domain, PCurve: None, Dom2: IntRes2d_Domain, TolConf: float, Tol: float) -> None: ...

class HLRBRep_TheLocateExtPCOfTheProjPCurOfCInter:
	@overload
	def __init__(self) -> None: ...
	@overload
	def __init__(self, P: gp_Pnt2d, C: None, U0: float, TolU: float) -> None: ...
	@overload
	def __init__(self, P: gp_Pnt2d, C: None, U0: float, Umin: float, Usup: float, TolU: float) -> None: ...
	def Initialize(self, C: None, Umin: float, Usup: float, TolU: float) -> None: ...
	def IsDone(self) -> bool: ...
	def IsMin(self) -> bool: ...
	def Perform(self, P: gp_Pnt2d, U0: float) -> None: ...
	def Point(self) -> Extrema_POnCurv2d: ...
	def SquareDistance(self) -> float: ...

class HLRBRep_ThePolygon2dOfTheIntPCurvePCurveOfCInter(Intf_Polygon2d):
	def __init__(self, Curve: None, NbPnt: int, Domain: IntRes2d_Domain, Tol: float) -> None: ...
	def ApproxParamOnCurve(self, Index: int, ParamOnLine: float) -> float: ...
	def AutoIntersectionIsPossible(self) -> bool: ...
	def CalculRegion(self, x: float, y: float, x1: float, x2: float, y1: float, y2: float) -> int: ...
	def Closed(self, clos: bool) -> None: ...
	def Closed(self) -> bool: ...
	def ComputeWithBox(self, Curve: None, OtherBox: Bnd_Box2d) -> None: ...
	def DeflectionOverEstimation(self) -> float: ...
	def Dump(self) -> None: ...
	def InfParameter(self) -> float: ...
	def NbSegments(self) -> int: ...
	def Segment(self, theIndex: int, theBegin: gp_Pnt2d, theEnd: gp_Pnt2d) -> None: ...
	def SetDeflectionOverEstimation(self, x: float) -> None: ...
	def SupParameter(self) -> float: ...

class HLRBRep_ThePolygonOfInterCSurf:
	@overload
	def __init__(self, Curve: gp_Lin, NbPnt: int) -> None: ...
	@overload
	def __init__(self, Curve: gp_Lin, U1: float, U2: float, NbPnt: int) -> None: ...
	@overload
	def __init__(self, Curve: gp_Lin, Upars: TColStd_Array1OfReal) -> None: ...
	def ApproxParamOnCurve(self, Index: int, ParamOnLine: float) -> float: ...
	def BeginOfSeg(self, Index: int) -> gp_Pnt: ...
	def Bounding(self) -> Bnd_Box: ...
	def Closed(self, clos: bool) -> None: ...
	def Closed(self) -> bool: ...
	def DeflectionOverEstimation(self) -> float: ...
	def Dump(self) -> None: ...
	def EndOfSeg(self, Index: int) -> gp_Pnt: ...
	def InfParameter(self) -> float: ...
	def NbSegments(self) -> int: ...
	def SetDeflectionOverEstimation(self, x: float) -> None: ...
	def SupParameter(self) -> float: ...

class HLRBRep_ThePolygonToolOfInterCSurf:
	@staticmethod
	def BeginOfSeg(self, thePolygon: HLRBRep_ThePolygonOfInterCSurf, Index: int) -> gp_Pnt: ...
	@staticmethod
	def Bounding(self, thePolygon: HLRBRep_ThePolygonOfInterCSurf) -> Bnd_Box: ...
	@staticmethod
	def Closed(self, thePolygon: HLRBRep_ThePolygonOfInterCSurf) -> bool: ...
	@staticmethod
	def DeflectionOverEstimation(self, thePolygon: HLRBRep_ThePolygonOfInterCSurf) -> float: ...
	@staticmethod
	def Dump(self, thePolygon: HLRBRep_ThePolygonOfInterCSurf) -> None: ...
	@staticmethod
	def EndOfSeg(self, thePolygon: HLRBRep_ThePolygonOfInterCSurf, Index: int) -> gp_Pnt: ...
	@staticmethod
	def NbSegments(self, thePolygon: HLRBRep_ThePolygonOfInterCSurf) -> int: ...

class HLRBRep_ThePolyhedronToolOfInterCSurf:
	@staticmethod
	def Bounding(self, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf) -> Bnd_Box: ...
	@staticmethod
	def ComponentsBounding(self, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf) -> Bnd_HArray1OfBox: ...
	@staticmethod
	def DeflectionOverEstimation(self, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf) -> float: ...
	@staticmethod
	def Dump(self, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf) -> None: ...
	@staticmethod
	def GetBorderDeflection(self, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf) -> float: ...
	@staticmethod
	def IsOnBound(self, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf, Index1: int, Index2: int) -> bool: ...
	@staticmethod
	def NbTriangles(self, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf) -> int: ...
	@staticmethod
	def Point(self, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf, Index: int) -> gp_Pnt: ...
	@staticmethod
	def TriConnex(self, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf, Triang: int, Pivot: int, Pedge: int) -> Tuple[int, int, int]: ...
	@staticmethod
	def Triangle(self, thePolyh: HLRBRep_ThePolyhedronOfInterCSurf, Index: int) -> Tuple[int, int, int]: ...

class HLRBRep_TheProjPCurOfCInter:
	@staticmethod
	def FindParameter(self, C: None, Pnt: gp_Pnt2d, Tol: float) -> float: ...
	@staticmethod
	def FindParameter(self, C: None, Pnt: gp_Pnt2d, LowParameter: float, HighParameter: float, Tol: float) -> float: ...

class HLRBRep_TheQuadCurvExactInterCSurf:
	def __init__(self, S: None, C: gp_Lin) -> None: ...
	def Intervals(self, Index: int) -> Tuple[float, float]: ...
	def IsDone(self) -> bool: ...
	def NbIntervals(self) -> int: ...
	def NbRoots(self) -> int: ...
	def Root(self, Index: int) -> float: ...

class HLRBRep_TheQuadCurvFuncOfTheQuadCurvExactInterCSurf(math_FunctionWithDerivative):
	def __init__(self, Q: IntSurf_Quadric, C: gp_Lin) -> None: ...
	def Derivative(self, Param: float) -> Tuple[bool, float]: ...
	def Value(self, Param: float) -> Tuple[bool, float]: ...
	def Values(self, Param: float) -> Tuple[bool, float, float]: ...

class HLRBRep_VertexList:
	def __init__(self, T: HLRBRep_EdgeInterferenceTool, I: HLRAlgo_ListIteratorOfInterferenceList) -> None: ...
	def BoundaryTransition(self) -> TopAbs_Orientation: ...
	def Current(self) -> HLRAlgo_Intersection: ...
	def IsBoundary(self) -> bool: ...
	def IsInterference(self) -> bool: ...
	def IsPeriodic(self) -> bool: ...
	def More(self) -> bool: ...
	def Next(self) -> None: ...
	def Orientation(self) -> TopAbs_Orientation: ...
	def Transition(self) -> TopAbs_Orientation: ...

class HLRBRep_Algo(HLRBRep_InternalAlgo):
	@overload
	def __init__(self) -> None: ...
	@overload
	def __init__(self, A: HLRBRep_Algo) -> None: ...
	def Add(self, S: TopoDS_Shape, SData: Standard_Transient, nbIso: Optional[int]) -> None: ...
	def Add(self, S: TopoDS_Shape, nbIso: Optional[int]) -> None: ...
	def Index(self, S: TopoDS_Shape) -> int: ...
	def OutLinedShapeNullify(self) -> None: ...

#classnotwrapped
class HLRBRep_ThePolyhedronOfInterCSurf:
	pass

#classnotwrapped
class HLRBRep_BSurfaceTool:
	pass

#classnotwrapped
class HLRBRep_Surface:
	pass

#classnotwrapped
class HLRBRep_TheCurveLocatorOfTheProjPCurOfCInter:
	pass
